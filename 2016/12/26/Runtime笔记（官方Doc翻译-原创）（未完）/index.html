<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="runtime," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Objective-C Runtime笔记（官方Doc翻译+原创）（未完）先上runtime指南官方地址: Objective-C Runtime Programming Guide Objective-C是一门动态语言，它将静态语言在编译和链接时期做的事放在运行时处理Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译代码，这个运行时系统即Objc Runtime，运行时系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime笔记（官方Doc翻译+原创）（未完）">
<meta property="og:url" content="http://yoursite.com/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/index.html">
<meta property="og:site_name" content="Jyq's blog">
<meta property="og:description" content="Objective-C Runtime笔记（官方Doc翻译+原创）（未完）先上runtime指南官方地址: Objective-C Runtime Programming Guide Objective-C是一门动态语言，它将静态语言在编译和链接时期做的事放在运行时处理Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译代码，这个运行时系统即Objc Runtime，运行时系统">
<meta property="og:updated_time" content="2016-12-26T07:50:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime笔记（官方Doc翻译+原创）（未完）">
<meta name="twitter:description" content="Objective-C Runtime笔记（官方Doc翻译+原创）（未完）先上runtime指南官方地址: Objective-C Runtime Programming Guide Objective-C是一门动态语言，它将静态语言在编译和链接时期做的事放在运行时处理Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译代码，这个运行时系统即Objc Runtime，运行时系统">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/"/>





  <title> Runtime笔记（官方Doc翻译+原创）（未完） | Jyq's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jyq's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">iOS</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Immanito">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Jyq's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Jyq's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Runtime笔记（官方Doc翻译+原创）（未完）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-26T15:47:55+08:00">
                2016-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/" class="leancloud_visitors" data-flag-title="Runtime笔记（官方Doc翻译+原创）（未完）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Objective-C-Runtime笔记（官方Doc翻译-原创）（未完）"><a href="#Objective-C-Runtime笔记（官方Doc翻译-原创）（未完）" class="headerlink" title="Objective-C Runtime笔记（官方Doc翻译+原创）（未完）"></a>Objective-C Runtime笔记（官方Doc翻译+原创）（未完）</h1><p>先上runtime指南官方地址:<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" title="Objective-C Runtime Programming Guide" target="_blank" rel="external"> Objective-C Runtime Programming Guide </a><br>Objective-C是一门<strong>动态语言</strong>，它将静态语言在编译和链接时期做的事放在运行时处理Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译代码，这个运行时系统即Objc Runtime，运行时系统作为OC语言的操作系统。尤其是它在运行时动态的加载类，并且向其他对象转发消息。它同时提供在你的程序运行时如何找到对象的信息。</p>
<p><em>Objc Runtime是一个用C语言和汇编语言编写的库</em>  </p>
<p>Objc Runtime有两个版本：<strong>Legacy</strong> 和<strong>Modern </strong>两个版本  </p>
<p>在Legacy版本中，如果你在类中改变了实例变量的布局，你必须重新编译继承它的类。<br>在Modern版本中，如果你在类中改变了实例变量的布局，你不需要重新编译继承它的类。<br>iPhone应用和在OS X v10.5上运行的64位程序以及以后的版本使用Modern版本。<br>其他程序（OS X 32位程序）使用Legacy版本。</p>
<hr>
<h2 id="与运行时系统的交互"><a href="#与运行时系统的交互" class="headerlink" title="与运行时系统的交互"></a>与运行时系统的交互</h2><p>OC程序在3个层次上与运行时系统进行交互:</p>
<ul>
<li>通过OC源代码</li>
<li>通过Foundation框架下NSObject类中定义的方法</li>
<li>通过直接调用运行时函数</li>
</ul>
<h3 id="OC源码"><a href="#OC源码" class="headerlink" title="OC源码"></a>OC源码</h3><p>大部分时候，运行时系统在后台自动工作，你需要做的仅仅是编写并运行OC源码。<br>当你编译包含OC类和方法的代码时，编译器为了实现语言的动态特性创建数据结构和函数调用。数据结构捕获类、类别定义和协议声明中的信息；它们包括OC语言中定义类时涉及到的类和协议对象，协议，以及SEL，实例变量模板，和其他从源码中提取的信息。主要的运行时函数是发送消息，它由源代码的消息表达式调用。</p>
<h3 id="NSObject方法"><a href="#NSObject方法" class="headerlink" title="NSObject方法"></a>NSObject方法</h3><p>大多数Cocoa中的对象都是NSObject类的子类，所以大多数对象都继承它定义的方法。（一个值得注意的例外是NSProxy类。）它的方法因此建立了每个实例和每个类对象固有的行为。然而，在少数情况下，NSObject类仅仅为了表明一些事情应该这么做而定义一个模板，它本身不提供任何必需的源码。</p>
<p>例如，NSObject类定义了一个实例方法description，这个方法返回一个描述该类内容的字符串。这主要用于调试——GDB打印对象 命令打印从这个方法返回的字符串，NSObject类的这个方法的实现不知道包含有什么类，所以它返回包含对象名字和地址的字符串。NSObject的子类可以实现这个方法来返回更多详细信息。例如：Foundation框架下的NSArray类返回它包含的所有对象的描述。<br>一些NSObject的方法简单地查询运行时系统的信息。这些方法允许对象执行自省（自我认知），这些举例列出的方法都是类方法，其要求对象识别他们的类；<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>它测试对象在继承层次结构中的位置；repondsToSelector:它表示一个对象能接受一个特定的消息，conformsToProtocol它表示一个对象是否实现了定义在特定协议中的方法；<code>methodForSelector:</code>提供了方法的实现地址。像这些方法给一个对象认识自身的能力。</p>
<h3 id="运行时函数"><a href="#运行时函数" class="headerlink" title="运行时函数"></a>运行时函数</h3><p>运行时系统是一个在位于<strong>/usr/include/objc</strong>的头文件中包含了一些列函数和数据结构的动态共享库，许多函数与允许你使用C语言硬编码去复写在你写OC代码时编译器做的事情。其他形式的基础功能导入时通过NSObject类的方法。这些函数使得开发其他面向运行时系统和增强开发环境的工具成为可能；它们不需要OC语言环境。然而，一部分运行时函数可能会不定期的被用来写OC程序。所有的这些函数都被记录在::Objective-C Runtime Reference::。(在API文档中查看)</p>
<hr>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>本节描述消息表达式是如何转为<code>objc_msgSend</code>的函数调用和如何通过方法名来引用一个方法。然后讲解如何利用<code>objc_msgSend</code>和如何绕过动态绑定。</p>
<h3 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h3><p>在OC中，直到运行时之前，消息不会被绑定到方法的实现。编译器会转换一个消息表达式:<br><code>[receiver message]</code><br>转变为一个消息函数的调用——<code>objc_msgSend</code>。函数带有接受者和方法提及的名字，作为方法选择器的两个主要参数:<br><code>objc_msgSend(receiver, selector)</code><br>任何传入消息的参数都被交给<code>objc_msgSend</code>:<br><code>1.    objc_msgSend(receiver, selector, arg1, arg2, ...);</code></p>
<p>消息函数做了所有动态绑定所必需的事情：</p>
<ul>
<li>它首先找到选择器所引用的方法实现。由于相同的方法可以被单独的类不同地实现，它找到的确切的方法实现取决于接受者所属的类。</li>
<li>然后它通过接收对象以及该方法所指定的所有参数来调用方法实现。</li>
<li>最后它通过调用方法实现的返回值来作为自己的返回值。</li>
</ul>
<p><strong>注意：编译器生成的调用消息函数，你绝对不能在你的代码中直接调用。</strong></p>
<p>消息的关键在于编译器为每个类和对象构建的结构，每个类结构包含两个必要的元素：</p>
<ul>
<li>一个指向父类的指针</li>
<li>一个类的调度表。这个表包含关联了方法选择器与它们标记的类特定方法的地址。<code>setOrigin:</code>方法的选择器与<code>setOrigin:</code>的地址关联起来，等等。</li>
</ul>
<p>当一个新的对象被创建的时候，内存会为它开辟一部分空间，它的实例变量同时被初始化。对象的所有变量中的第一个是一个指向它的类结构的指针，这个指针叫做<strong>isa指针</strong>，提供给对象访问它的类，通过类，到达所有该类继承的类。</p>
<p>注意：严格说虽然不是语言的一部分，isa指针对于工作在OC运行时系统中的对象来说是必须的。一个对象需要与结构体<code>struct objc_object</code>::在objc/objc.h中定义::中定义的任何字段“等同”，但是，你很少，如果有需要创建你自己的根对象，从NSObject或者NSProxy集成而来的类对象都自动拥有isa变量。</p>
<p><img src="" alt=""></p>
<p>当一条消息发送给一个对象的时候，消息函数跟随对象的isa指针到它的类结构，在调度表中查找方法的选择器，如果他不能在那找到选择器，<code>objc_msgSend</code>跟随指针来到父类并且试着在调度表中找到选择器，连续的失败会使<code>objc_msgSend</code>沿着继承机构向上寻找直到它到达NSObject类，一旦它发现选择器，该函数调用表中输入的方法并将其传递给接收对象的数据结构。</p>
<p><strong>这里着重说明一个知识点：</strong><br>       <em>在一个类中调用<code>[super class]</code>很多初学者会认为输出父类的名字，但是结果却还是与<code>[self class]</code>相同的输出，而又不理解，其实self是类的隐藏参数，指向当前调用方法的类，另一个隐藏参数是<code>_cmd</code>前面已经介绍过，带表当前方法的selector，这里只关注这个self，而super并不是一个隐藏参数，它是一个“编译器指示符”，和self指向相同的消息接受者，<code>[self class]</code>和<code>[super class]</code>，接收class消息的都是指向当前类的指针，而不是想当然的super指向的父类，不同之处在于super只是告诉编译器，调用方法是要去调用父类的class方法而不是本类的，其实self和super最后调用的都是NSObject定义的方法，输出本类的类名，所以才会出现上面那种结果。</em></p>
<p>这就是方法实现在运行时才会确定的实现方式，或者用面向对象编程的行话，那些方法与消息动态绑定。</p>
<p>为了加快消息的传递过程，运行时系统缓存它们用到的选择器和方法的地址，每一个类都有一个单独的缓存，它能包含继承方法，就像它们自己定义的一样。在搜索调度表之前，发送消息例行在它的接收对象的类的缓存中查找（理论上，一个方法被使用一次可能会被再次使用），如果方法选择器在缓存中，消息传递仅仅比函数调用略微慢一点点。一旦一个程序已经运行的足够长的时间来“预热”它的缓存，几乎所有的消息都会找到缓存方法，在程序运行过程中，缓存动态增加来容纳新消息。</p>
<h3 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h3><p>当<code>objc_msgSend</code>找到了方法实现的程序段，它调用这段程序并传递消息中的所有参数，它也会传递给这段程序两个隐藏的参数：</p>
<ul>
<li>接收对象</li>
<li>方法的选择器</li>
</ul>
<p>这些参数给它的方法实现提供显示的关于两半调用它的消息表达式的信息。他们被称为是隐藏的是因为它们并不会被声明在它们定义的源码中，当源码被编译的时候，这两个参数会被插入到实现中。</p>
<p>尽管这些参数并不是显示声明的，源码仍然能够引用到它们（就像它能够引用到接受对象的实例变量一样）。一个引用接收对象为——self,引用他自己的方法选择器为——<code>_cmd</code>。在下面的例子中，<code>_cmd</code>引用strange的方法选择器，引用self作为接收strange消息的对象。</p>
<pre><code>- strange  
{  
    id  target = getTheReceiver();  
    SEL method = getTheMethod();  

    if ( target == self || method == _cmd )  
        return nil;  
    return [target performSelector:method];  
}  
</code></pre><p>self在两个参数中更有用一些,事实上，这是接收的对象的实例变量对于方法定义变得可用的方式。</p>
<h3 id="得到一个方法地址"><a href="#得到一个方法地址" class="headerlink" title="得到一个方法地址"></a>得到一个方法地址</h3><p>绕过动态绑定的唯一方式就是得到方法的地址并像调用函数一样调用它。这在极少数场合是合适的，当一个特定的方法被连续调用多次的时候而且你想避免方法每次被执行发送消息的开销。</p>
<p>一个定义在NSObject类中的方法，<code>methodForSelector:</code>你可以要求一个指向实现一个方法的过程的指针，然后用指针调用这个过程，<code>methodForSelector:</code>返回的指针必须仔细转换到恰当的函数类型。返回和参数类型都应该包含在转换中。</p>
<p>下面的例子展示了setFilled:方法的实现过程如何被调用：<br>    void (*setter)(id, SEL, BOOL);<br>    int i;  </p>
<pre><code>setter = (void (*)(id, SEL, BOOL))[target  
    methodForSelector:@selector(setFilled:)];  
for ( i = 0 ; i &lt; 1000 ; i++ )  {
    setter(targetList[i], @selector(setFilled:), YES);  
}
</code></pre><p>第一次被传过去的两个参数是接收对象self和方法选择器<code>_cmd</code>。<br>这些参数在方法语法中被隐藏，但是当方法被当做函数调用的时候必须显示的传递。</p>
<p>使用<code>methodForSelector:</code>来规避动态绑定节约了大量发送消息所需的时间，要使节省变得有意义，必须当一个特定的消息重复很多次的时候，就像上面for循环展示的那样。</p>
<p>使用<code>methodForSelector:</code>来规避动态绑定节约了大量发送消息所需的时间，要使节省变得有意义，必须当一个特定的消息重复很多次的时候，就像上面for循环展示的那样。</p>
<hr>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p><em>这节描述了如何动态地提供一个方法。</em></p>
<h3 id="动态方法解析-1"><a href="#动态方法解析-1" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>有时你会想要动态地提供一个方法的实现，例如，OC声明属性特性包含@dynamic关键字<br><code>@dynamic propertyName;</code><br>告诉编译器与属性关联的方法会被动态地提供。</p>
<p>你可以实现方法resolveInstanceMethod:和方法resolveClassMethod:来分别地动态提供一个给定selector，实例和类名的方法实现。<br>一个OC方法的根本就是带有self和<code>_cmd</code>两个参数的C函数，你可以用函数<code>class_addMethod</code>来添加一个函数到类中去作为方法。因此给出以下函数:<br>    void dynamicMethodIMP(id self, SEL _cmd) {<br>        // implementation ….<br>    }</p>
<p>你可以使用方法<code>resolveInstanceMethod:</code>动态添加它的实现到类中作为方法（resolveThisMethodDynamically):<br>    @implementation MyClass  </p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL  
{  
    if (aSEL == @selector(resolveThisMethodDynamically)) {  
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);  
          return YES;  
    }  
    return [super resolveInstanceMethod:aSEL];  
}  
@end  
</code></pre><p>官方的runtime编程指南到这里就没在继续详细讲解了，你可以喷我，但我还是想说，新手根本看不懂所以还要再增加篇幅从头讲。</p>
<p>每个方法都有一个<strong>SEL(selector)</strong>和一个<strong>IML(implement)</strong>，SEL可以随便写，但是不一定有对应的IML，如果消息函数沿着继承层次结构找到了顶端还是找不到对应的方法实现，就会抛出异常而crash。</p>
<p>上文提到“消息函数做了所有动态绑定所必需的事情：它首先找到选择器所引用的方法实现。”但是如果一直没有找到，就会开始尝试动态解析，消息转发，标准消息转发：<br><img src="" alt=""></p>
<p>其实这就是通过SEL查找IML，这个过程也可以用下图表示：<br><img src="" alt=""></p>
<h3 id="resolveInstanceMethod函数"><a href="#resolveInstanceMethod函数" class="headerlink" title="resolveInstanceMethod函数"></a>resolveInstanceMethod函数</h3><p>函数原型是：<br><code>1.    + (BOOL)resolveInstanceMethod:(SEL)name;</code></p>
<p>在运行时（runtime），SEL没有找到对应的IML就会先执行这个函数，这个函数是给类利用<code>class_addMethod</code>添加方法的机会。如果实现了添加方法的代码则返回YES，如果没有实现则返回NO。<br>新建一个工程在.m文件添加如下代码：</p>
<pre><code>#import &quot;ViewController.h&quot;  

@interface ViewController()  

@end  

@implement ViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
    [self performSelector:@selector(doSomething:)];  
}  

- (void)didReceiveMemoryWarning{  
    [super didReveiceMemoryWarning];  
}  
</code></pre><p>结果就是程序crash控制台报错：<br><code>terminating with uncaught exceptionof type NSException</code></p>
<p>因为程序没有找到doSomething:这个方法，下面我们实现:<br><code>1.    + (BOOL)resolveInstanceMethod:(SEL)sel;</code></p>
<p>并且判断若果sel是doSomething:那就说出add method here</p>
<pre><code>#import &quot;ViewController.h&quot;  

@interface ViewController()  

@end  

@implement ViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
    [self performSelector:@selector(doSomething)];  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel{  
    if(sel == @selector(doSomething)){  
        NSLog(@&quot;add method here!&quot;);  
        return YES;  
    }  
    return NO;  
}  

- (void)didReceiveMemoryWarning{  
    [super didReveiceMemoryWarning];  
}  
</code></pre><p>运行查看控制台发现程序虽然崩溃了，但是控制台输出的第一句话就是add method here! 说明确实进入了这个方法并且通过了判断。</p>
<p>所以我们可以在if语句里做一下操作，使得这个方法的得到实现而不至于走到方法：<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector;</code></p>
<p>走到这个方法就会Crash，接下来我们继续更改</p>
<pre><code>#import &quot;ViewController.h&quot;  

@interface ViewController()  

@end  

@implement ViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
    [self performSelector:@selector(doSomething:)];  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel{  
    if(sel == @selector(doSomething)){  
        NSLog(@&quot;add method here!&quot;);  
        class_addMethod([self class], sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;);  
        return YES;  
    }  
    return [super resolveInstanceMethod:sel];  
}  

void dynamicMethodIMP(id self, SEL _cmd){  
    NSLog(@&quot;doSomthing SEL&quot;);  
}  

- (void)didReceiveMemoryWarning{  
    [super didReveiceMemoryWarning];  
}  
</code></pre><p>定义了一个<code>void dynamicMethodIMP(id self, SEL _cmd)</code>这个函数，并且在<br><code>+ （BOOL)resolveInstanceMethod:(SEL)sel</code>方法中执行了<code>class_addMethod</code>方法，运行工程我们查看Log：<br>    add method here!<br>    doSomething SEL  </p>
<p>程序成功输入，这说明我们已经通过runtime成功向我们这个类中添加了一个方法，这里说几点注意事项：</p>
<p>首先<code>class_addMethod</code>是定义在<strong>\<objc runtime.h\=""></objc></strong>中的方法，使用前要导入头文件，前几个查找IML的方法是定义在NSObject中的方法，所以无需导入头文件。<br>我们再来看一下<code>class_addMethod</code>的方法定义<br><code>class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const charchar *types)</code></p>
<ul>
<li>cls 方法所要添加到的类</li>
<li>name 方法名字可以随意起</li>
<li>imp 实现方法的函数</li>
<li>types 定义该函数返回值类型和参数类型（依次按序输入）的字符串，注意这个参数不是NSString类型，而是<code>const char *</code>类型 所以不要用@“”,而要直接用””，我们上面的函数是 <code>void dynamicMethod（id self, SEL _cmd）</code> 返回值是void——（对应）v ; 第一个参数是self——（对应）@  第二个参数是SEL——（对应）：，所以连起来就是“v@:”就是此处该写入的参数。</li>
</ul>
<p>再举个例子：<br>    int newMethod(id self, SEL _cmd, NSString *str){<br>        return 100;<br>    }  </p>
<p>那么添加这个函数的方法就是<br><code>class_addMethod([self class], SEL name, IMP imp, &quot;i@:@&quot;);</code></p>
<h3 id="forwardingTargetForSelector函数"><a href="#forwardingTargetForSelector函数" class="headerlink" title="forwardingTargetForSelector函数"></a>forwardingTargetForSelector函数</h3><p>如果在+ （BOOL）resolveInstanceMethod:(SEL)sel中没有找到或者添加方法，消息继续往下传递到<br><code>-(id)forwardingTargetForSelector:(SEL)aSelector</code></p>
<p>看看是不是有对象可以执行这个方法，我们再原有例子的基础上在新建一个类</p>
<pre><code>#import&quot;SecondViewController.h&quot;  

@interface SecondViewController  

@end  

@implementation SecondViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
}  

- (void)secondVCMethod{  
    NSLog(@&quot;This is secondVC method&quot;);  
}  

- (void)didReceiveMemoryWarning{  
    [super didReceiveMemoryWarning];  
}  
</code></pre><p>添加好后我们要在ViewController 中调用secondVCMethod，可是这个两个类并没有继承关系，正常是无法调用的</p>
<p>在ViewController中</p>
<pre><code>#import &quot;ViewController.h&quot;  

@interface ViewController()  

@end  

@implement ViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
    [self performSelector:@selector(secondVCMethod)];  
}  

- (void)didReceiveMemoryWarning{  
    [super didReveiceMemoryWarning];  
} 
</code></pre><p>这样调用肯定会找不到方法而崩溃，下面我们是用forwardingTargetForSelector方法来转发一下消息，继续处理ViewConreoller类</p>
<pre><code>#import &quot;ViewController.h&quot;  

@interface ViewController()  

@end  

@implement ViewController  

- (void)viewDidLoad{  
    [super viewDidLoad];  
    [self performSelector:@selector(secondVCMethod)];  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel{  
    return [super resolveInstanceMethod:sel];  
}  

- (id)forwadingTargetForSelector:(SEL)aSelector{  
    Class class = NSClassFromString(@&quot;SecondViewController&quot;);  
    UIViewController * vc = class.new;  
    if(aSelector == NSSelectorFromString(@&quot;secondVCMethod&quot;)){  
        NSLog(@&quot;secondVC do this&quot;);  
        return vc;  
    }  
    return nil;  
}  

- (void)didReceiveMemoryWarning{  
    [super didReveiceMemoryWarning];  
} 
</code></pre><p>我们会发现secondVCMethod方法执行了，程序并没有崩溃，原因在于当没有找到secondVCMethod这个方法的时候消息一直传递到方法<br><code>- (id)forwadingTargetForSelector:(SEL)aSelector</code></p>
<p>然后在里面创建了一个SecondViewController的对象，并判断如果这个需要转发的方法是secondViewController中的方法就返回secondViewController的对象，消息成功转发给secondViewController的对象，并执行。同时也相当于完成了一个多继承。</p>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>一个OC程序可以在运行的时候绑定并连接新的类和分类。新的代码会被合并到程序中，与一开始就加载的代码没有区别。<br>动态加载可以被用来做血多不同的事情，例如，在系统APP的许多模块都是动态绑定。<br>在Cocoa环境下，动态绑定通常被用来自定义APP。其他则是用来写一些运行时加载的组件——就像Interface Builder加载定制的调色板和OS X系统应用加载自定义模块一样，可加载模块扩展了你的应用可以做什么，它们的贡献在于你提供框架，他人提供代码。<br>虽然运行时函数在Mach-O文件中执行动态绑定（<code>objc_loadModiles</code>,在<code>objc_load.h</code>中定义），Cocoa的NSbundle类为动态帮顶提供了一个显着更方便的接口——一种面向对象并与相关服务集成的接口。在Foundation框架查看NSBundle类的说明参考类的信息和它所使用的。通过 <strong>《OS X ABI Mach-O 文件格式参考》</strong>查看Mach-O文件的信息。</p>
<hr>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>向一个对象发送消息，对象没有处理消息，就会报错。然而，在报错之前，运行时系统给接收消息的对象两个选择去处理消息。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>如果你给一个对象发送消息，并且这个对象没有处理这个消息，在抛出一个错误之前，运行时系统会向对象发送一个消息：<br><code>forwardInvocation:</code></p>
<p>用NSInvocation作为它的唯一实参，通过NSInvocation对象封装了原始的消息和实参<strong>(未完成)</strong></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/runtime/" rel="tag"># runtime</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/23/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/"
     data-title="Runtime笔记（官方Doc翻译+原创）（未完）"
     data-content=""
     data-url="http://yoursite.com/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/"
           data-title="Runtime笔记（官方Doc翻译+原创）（未完）" data-url="http://yoursite.com/2016/12/26/Runtime笔记（官方Doc翻译-原创）（未完）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Immanito" />
          <p class="site-author-name" itemprop="name">Immanito</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Immanito" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2335788521" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Objective-C-Runtime笔记（官方Doc翻译-原创）（未完）"><span class="nav-number">1.</span> <span class="nav-text">Objective-C Runtime笔记（官方Doc翻译+原创）（未完）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#与运行时系统的交互"><span class="nav-number">1.1.</span> <span class="nav-text">与运行时系统的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OC源码"><span class="nav-number">1.1.1.</span> <span class="nav-text">OC源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSObject方法"><span class="nav-number">1.1.2.</span> <span class="nav-text">NSObject方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">运行时函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息机制"><span class="nav-number">1.2.</span> <span class="nav-text">消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-msgSend函数"><span class="nav-number">1.2.1.</span> <span class="nav-text">objc_msgSend函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用隐藏参数"><span class="nav-number">1.2.2.</span> <span class="nav-text">使用隐藏参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#得到一个方法地址"><span class="nav-number">1.2.3.</span> <span class="nav-text">得到一个方法地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态方法解析"><span class="nav-number">1.3.</span> <span class="nav-text">动态方法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态方法解析-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resolveInstanceMethod函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">resolveInstanceMethod函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forwardingTargetForSelector函数"><span class="nav-number">1.3.3.</span> <span class="nav-text">forwardingTargetForSelector函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载"><span class="nav-number">1.4.</span> <span class="nav-text">动态加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息转发"><span class="nav-number">1.5.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转发"><span class="nav-number">1.5.1.</span> <span class="nav-text">转发</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Immanito</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"immanito"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  










  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("P3KiVX7LwmJJ31A8Yk93IkNs-gzGzoHsz", "JoBrepUtw1vfKwVlvpawA7MW");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
